# Structural Variants



NOTE

```bash
# We need to remap all the data because GRIDSS doesn't support realigned GATK bams. GATK hardclips
# when realigning and you cannot retrieve that data downstream.

```

REMAPPING

```bash

cat Hybrid.samples | while read f ;
do mkdir tmp.${f} ;
sbatch Paleomix_Saga_Submit_Modern_NUMT.sh ${f}.yaml ;
done ;

mkdir Bams
cd Bams
cat ../Mapping/Hybrid.samples | while read line ;
do echo ${line} ;
cp ../Mapping/${line}/${line}.Puffin_ReferenceGenome.NU.MT.ba* . ;
done
cd ../

```

GET BAMFILES

```bash

mkdir Realigned
mkdir NotRealigned

#ForGridss
cp Bams/*bam NotRealigned/

#Rest
cp Paleomix/MappingContactZone/*/*.Puffin_ReferenceGenome.NU.MT.realigned.bam Realigned/

```

Clip

```bash

mkdir Realigned/Clipped
mkdir NotRealigned/Clipped

ls Realigned/*.bam | while read line ;
do echo $line ;
file=$(echo $line | awk -F '/' '{print $2}') ;
echo $file ;
sbatch Clip1.sh ${file} ;
done

ls NotRealigned/*.bam | while read line ;
do echo $line ;
file=$(echo $line | awk -F '/' '{print $2}') ;
echo $file ;
sbatch Clip2.sh ${file} ;
done

```

Clip1.sh

```bash

module load BamUtil/1.0.14-intel-2018b
module load SAMtools/1.9-GCC-7.3.0-2.30

REALIGNFOLDER=Realigned
CLIPFOLDER=Realigned/Clipped
file=$(echo ${1})
PREFIX=$(basename $file .realigned.bam)

cd ${REALIGNFOLDER}

# Clip overlap
bam clipOverlap \
--in ${file} \
--out ${CLIPFOLDER}/${PREFIX}.temp.bam \
--unmapped --storeOrig OC --stats

# Remove the reads that became unmapped in the clipping
samtools view -hb -F 4 \
${CLIPFOLDER}/${PREFIX}.temp.bam \
> ${CLIPFOLDER}/${PREFIX}.no_overlap.bam

# Index bam
samtools index ${CLIPFOLDER}/${PREFIX}.no_overlap.bam

# Cleanup
rm ${CLIPFOLDER}/${PREFIX}.temp.bam

```

Clip2.sh

```bash

module load BamUtil/1.0.14-intel-2018b
module load SAMtools/1.9-GCC-7.3.0-2.30

REALIGNFOLDER=NotRealigned
CLIPFOLDER=NotRealigned/Clipped
file=$(echo ${1})
PREFIX=$(basename $file .bam)

cd ${REALIGNFOLDER}

# Clip overlap
bam clipOverlap \
--in ${file} \
--out ${CLIPFOLDER}/${PREFIX}.temp.bam \
--unmapped --storeOrig OC --stats

# Remove the reads that became unmapped in the clipping
samtools view -hb -F 4 \
${CLIPFOLDER}/${PREFIX}.temp.bam \
> ${CLIPFOLDER}/${PREFIX}.no_overlap.bam

# Index bam
samtools index ${CLIPFOLDER}/${PREFIX}.no_overlap.bam

# Cleanup
rm ${CLIPFOLDER}/${PREFIX}.temp.bam

```

Ref+Samples+Rscripts

```bash

mkdir Ref
cp Puffin_ReferenceGenome.NU.MT.FINAL.fasta* Ref/
cp ../../../Paleomix/Reference/Puffin_ReferenceGenome.NU.MT.fasta* Ref/

cp ../SV/samples .

svn checkout https://github.com/clairemerot/SR_SV/trunk/01_scripts/Rscripts
svn checkout https://github.com/clairemerot/genotyping_SV/trunk/01_scripts/Rscripts

#check and edit source() in each R script

#also edit the manta R script -> account for the fact that some start at 0 
# pos <- ifelse(start == 1, 1, ifelse(start == 0, 1, start - 1))

```

Delly

```bash

mkdir Delly
cd Delly

cat ../samples | while read line ;
do echo ${line} ;
sbatch Delly1.sh ${line} ;
done

```

Delly1.sh

```bash

module load Miniconda3/4.9.2
conda activate miniconda3_envs/delly
module load BCFtools/1.9-intel-2018b

delly call -g ../Ref/Puffin_ReferenceGenome.NU.MT.fasta -o ${1}.bcf ../Bams/Realigned/Clipped/${1}.Puffin_ReferenceGenome.NU.MT.no_overlap.bam

cd Delly

rm slurm*

module purge
module load Miniconda3/4.9.2
conda activate miniconda3_envs/delly
module load BCFtools/1.9-intel-2018b

delly merge -o SPI_BJO_ROS_sites.bcf \
BJO001.bcf \
BJO003.bcf \
BJO005.bcf \
BJO006.bcf \
BJO007.bcf \
BJO008.bcf \
ROS001.bcf \
ROS002.bcf \
ROS003.bcf \
ROS006.bcf \
ROS007.bcf \
ROS008.bcf \
SPI001.bcf \
SPI002.bcf \
SPI003.bcf \
SPI004.bcf \
SPI011.bcf \
SPI015.bcf

bcftools view SPI_BJO_ROS_sites.bcf > SPI_BJO_ROS_sites.vcf

echo "nb of SV detected by Delly"
grep -v "#" SPI_BJO_ROS_sites.vcf | wc -l

#57,650 

conda deactivate

```

Filter Delly

```bash

module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

bgzip SPI_BJO_ROS_sites.vcf

INPUT_VCF=SPI_BJO_ROS_sites.vcf.gz # we will try not to modify this one
VCF_FOLDER=TMP_VCF
OUTPUT_VCF=SPI_BJO_ROS_delly.vcf
RScripts=SV_Merot/Rscripts
RefFasta=SV_Merot/Ref/Puffin_ReferenceGenome.NU.MT.fasta

mkdir ${VCF_FOLDER}
cp $INPUT_VCF ${VCF_FOLDER}/raw.vcf.gz
gunzip ${VCF_FOLDER}/raw.vcf.gz

#check what it oolk like
#grep -v ^\#\# $VCF_FOLDER/raw.vcf | head 
#tail $VCF_FOLDER/raw.vcf 
echo "total number of SVs"
grep -v "#" ${VCF_FOLDER}/raw.vcf | wc -l  

#filter out TRA & BND & INS
bcftools filter -i'INFO/SVTYPE!="TRA" & INFO/SVTYPE!="BND" & INFO/SVTYPE!="INS"' -o ${VCF_FOLDER}/raw.noTRA.vcf -Ov ${VCF_FOLDER}/raw.vcf 
#grep -v ^\#\# $VCF_FOLDER/raw_sorted.noTRA.vcf | head
echo "total number of SVs restricted to  DEL, INV, DUP"
grep -v "#" ${VCF_FOLDER}/raw.noTRA.vcf | wc -l 

#Keep INS and add the sequence of INS
bcftools filter -i 'INFO/SVTYPE=="INS"' -o ${VCF_FOLDER}/raw.INS.vcf -Ov ${VCF_FOLDER}/raw.vcf 
grep -v "#" ${VCF_FOLDER}/raw.INS.vcf | wc -l 
#put the field consensus in ALT
bcftools query -f '%CHROM\t%POS\t%ID\t%REF\t%INFO/CONSENSUS\t%QUAL\t%FILTER\n' ${VCF_FOLDER}/raw.INS.vcf > ${VCF_FOLDER}/raw.INS.info1
cat ${VCF_FOLDER}/raw.INS.vcf | grep -v "#" | cut -f8 > ${VCF_FOLDER}/raw.INS.info2
paste ${VCF_FOLDER}/raw.INS.info1 ${VCF_FOLDER}/raw.INS.info2 > ${VCF_FOLDER}/raw.INS.info

#re-merge everything
grep ^"#" ${VCF_FOLDER}/raw.vcf > ${VCF_FOLDER}/raw_sorted.noTRA.vcf
(grep -v ^"#" ${VCF_FOLDER}/raw.noTRA.vcf; grep -v ^"#" ${VCF_FOLDER}/raw.INS.info) | sort -k1,1 -k2,2n >> ${VCF_FOLDER}/raw_sorted.noTRA.vcf

#grep -v ^\#\# $VCF_FOLDER/raw_sorted.vcf | head
echo "total number of SVs"
grep -v "#" ${VCF_FOLDER}/raw_sorted.noTRA.vcf | wc -l 

#we need to add a field for SVLEN
##step 1 export position 
bcftools query -f '%CHROM\t%POS\t%INFO/END\n' ${VCF_FOLDER}/raw_sorted.noTRA.vcf > ${VCF_FOLDER}/raw_sorted.noTRA.info

#step 2 calculate length
module purge
module load R/4.1.0-foss-2021a
Rscript ${RScripts}/add_info_bcf.r ${VCF_FOLDER}/raw_sorted.noTRA.info 

module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

bgzip ${VCF_FOLDER}/raw_sorted.noTRA.info.annot
tabix -s1 -b2 -e2 ${VCF_FOLDER}/raw_sorted.noTRA.info.annot.gz

##step3 prepare the header
echo -e '##INFO=<ID=SVLEN,Number=.,Type=Integer,Description="Difference in length between REF and ALT alleles">' > ${VCF_FOLDER}/raw_sorted.noTRA.info.annot.hdr

##step4 run bcftools annotate
#-a is the annotation file (tabix and bgzip, it needs at least CHROM and POS, -h are the header lines to add, -c are the meaning of the column in the annotation file
bcftools annotate -a ${VCF_FOLDER}/raw_sorted.noTRA.info.annot.gz -h ${VCF_FOLDER}/raw_sorted.noTRA.info.annot.hdr -c CHROM,POS,INFO/SVLEN ${VCF_FOLDER}/raw_sorted.noTRA.vcf > ${VCF_FOLDER}/raw_sorted.noTRA_bis.vcf

#filter vcf -i (include, -O vcf format -o
bcftools filter -i'INFO/SVLEN>=50 | INFO/SVLEN<=-50' -o ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf -Ov ${VCF_FOLDER}/raw_sorted.noTRA_bis.vcf
echo "total number of SVs > 50b"
grep -v ^\#\# ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf | wc -l 

#then we use the reference to get the sequence with a R scripts graciously provided by Marc-AndrÃ© Lemay
module purge
module load R/4.1.0-foss-2021a
Rscript ${RScripts}/add_explicit_seq_delly.r ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf ${RefFasta}

#Export sequences for advanced filtering
module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0
bcftools query -f '%CHROM %POS %INFO/END %INFO/SVTYPE %INFO/SVLEN %REF %ALT\n' ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf > ${VCF_FOLDER}/SV_data_with_seq.txt

#blacklist because of N string > 10 (possible junction of contigs 
grep -P "N{10,}" ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{print $1 "\t" $2 "\t" $6 "\t" $7}' > ${VCF_FOLDER}/N10_blacklist.bed
echo "SVs excluded because of >10N" 
wc -l ${VCF_FOLDER}/N10_blacklist.bed 

#blacklist because missing seq
cat ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{if ($6 == "N") print $1 "\t" $2 "\t" $6 "\t" $7;}' > ${VCF_FOLDER}/N_blacklist.bed
echo "SVs excluded because absence of sequence ref" 
wc -l ${VCF_FOLDER}/N_blacklist.bed 

#blacklist because missing seq
cat  ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{print $1 "\t" $2 "\t" $6 "\t" $7}' | grep -P "<" > ${VCF_FOLDER}/N_blacklist_bis.bed
echo "SVs excluded because absence of sequence alt" 
wc -l ${VCF_FOLDER}/N_blacklist_bis.bed 

#full blacklist
cat ${VCF_FOLDER}/N_blacklist.bed ${VCF_FOLDER}/N_blacklist_bis.bed ${VCF_FOLDER}/N10_blacklist.bed | sort -k1,1 -k2,2n > ${VCF_FOLDER}/blacklist.bed
#head $VCF_FOLDER/blacklist.bed
bgzip -c ${VCF_FOLDER}/blacklist.bed > ${VCF_FOLDER}/blacklist.bed.gz
tabix -s1 -b2 -e2 ${VCF_FOLDER}/blacklist.bed.gz

#remove blacklist of variants
bcftools view -T ^${VCF_FOLDER}/blacklist.bed.gz ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf > ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf
echo "SVs after filtration for N seq" 
grep -v "#" ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf | wc -l 

#keep the filtered vcf
cp ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf ${OUTPUT_VCF}
bgzip -c ${OUTPUT_VCF} > ${OUTPUT_VCF}.gz
tabix ${OUTPUT_VCF}.gz

```

Manta

```bash

mkdir Manta
cd Manta

module purge
module load Miniconda3/4.9.2

conda activate miniconda3_envs/manta

configManta.py \
--bam ../Bams/Realigned/Clipped/BJO001.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/BJO003.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/BJO005.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/BJO006.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/BJO007.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/BJO008.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/ROS001.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/ROS002.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/ROS003.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/ROS006.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/ROS007.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/ROS008.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/SPI001.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/SPI002.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/SPI003.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/SPI004.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/SPI011.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--bam ../Bams/Realigned/Clipped/SPI015.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
--referenceFasta ../Ref/Puffin_ReferenceGenome.NU.MT.fasta \
--runDir .

conda deactivate

sbatch Manta.sh 
```

Manta.sh

```bash


module load Miniconda3/4.9.2
conda activate miniconda3_envs/manta

Manta/runWorkflow.py --jobs 16 --memGb 32

```

Filter Manta

```bash
gunzip -c results/variants/diploidSV.vcf.gz > manta_SV.vcf

echo "nb of SV detected by Manta"
grep -v ^\#\# manta_SV.vcf | wc -l


module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

bgzip manta_SV.vcf

INPUT_VCF=manta_SV.vcf.gz # we will try not to modify this one
VCF_FOLDER=TMP_VCF
OUTPUT_VCF=SPI_BJO_ROS_manta.vcf
RScripts=SV_Merot/Rscripts
RefFasta=SV_Merot/Ref/Puffin_ReferenceGenome.NU.MT.fasta

mkdir ${VCF_FOLDER}
cp $INPUT_VCF ${VCF_FOLDER}/raw.vcf.gz
gunzip ${VCF_FOLDER}/raw.vcf.gz

#check what it oolk like
#grep -v ^\#\# $VCF_FOLDER/raw.vcf | head 
#tail $VCF_FOLDER/raw.vcf 
echo "total number of SVs"
grep -v "#" ${VCF_FOLDER}/raw.vcf | wc -l 

# Manta file needs to be adjusted. Inversions need to be converted
# First to INV5 and 3 output
# then select smallest of the two
cp ${VCF_FOLDER}/raw.vcf ${VCF_FOLDER}/raw.initial.vcf
module purge
module load Miniconda3/4.9.2

conda activate miniconda3_envs/manta

miniconda3_envs/manta/share/manta-1.6.0-1/libexec/convertInversion.py \
miniconda3_envs/manta/share/manta-1.6.0-1/libexec/samtools \
../Ref/Puffin_ReferenceGenome.NU.MT.fasta \
${VCF_FOLDER}/raw.initial.vcf > ${VCF_FOLDER}/raw.initial2.vcf

conda deactivate

grep "#" ${VCF_FOLDER}/raw.initial2.vcf  > ${VCF_FOLDER}/Manta_header
grep -v "#" ${VCF_FOLDER}/raw.initial2.vcf  > ${VCF_FOLDER}/Manta_body

cp ${VCF_FOLDER}/Manta_body ${VCF_FOLDER}/Manta_body_edit
cat ${VCF_FOLDER}/Manta_body | grep "MantaINV" | grep "EVENT" | grep "INV5" | cut -f3 | awk -F ':' '{print $1":"$2":"$3":"$4":"}' | while read line ;
do start1=$(grep ${line} ${VCF_FOLDER}/Manta_body | head -1 | cut -f2)
start2=$(grep ${line} ${VCF_FOLDER}/Manta_body | tail -1 | cut -f2)
if [[ ${start1} -gt ${start2} ]]
then
	rmID=$(grep ${line} ${VCF_FOLDER}/Manta_body | tail -1 | cut -f3)
else
	rmID=$(grep ${line} ${VCF_FOLDER}/Manta_body | head -1 | cut -f3)
fi
awk -v rmID=$rmID '$3!=rmID {print $0}' ${VCF_FOLDER}/Manta_body_edit > ${VCF_FOLDER}/tmp 
mv ${VCF_FOLDER}/tmp ${VCF_FOLDER}/Manta_body_edit ;
done 

#Other "normal" inversions with 2 partner entries need to be represented by only 1 entry
cp ${VCF_FOLDER}/Manta_body_edit ${VCF_FOLDER}/Manta_body_edit2
grep "INV" ${VCF_FOLDER}/Manta_body_edit | grep -v "EVENT" | cut -f3 | awk -F ':' '{print $1":"$2":"$3":"$4":"}' | while read line ;
do start1=$(grep ${line} ${VCF_FOLDER}/Manta_body_edit | head -1 | cut -f2) ;
start2=$(grep ${line} ${VCF_FOLDER}/Manta_body_edit | tail -1 | cut -f2) ;
if [[ ${start1} -gt ${start2} ]]
then
	rmID=$(grep ${line} ${VCF_FOLDER}/Manta_body_edit | tail -1 | cut -f3)
	awk -v rmID=$rmID '$3!=rmID {print $0}' ${VCF_FOLDER}/Manta_body_edit2 > ${VCF_FOLDER}/tmp 
	mv ${VCF_FOLDER}/tmp ${VCF_FOLDER}/Manta_body_edit2
elif [[ ${start1} -lt ${start2} ]]	
then
	rmID=$(grep ${line} ${VCF_FOLDER}/Manta_body_edit | head -1 | cut -f3)
	awk -v rmID=$rmID '$3!=rmID {print $0}' ${VCF_FOLDER}/Manta_body_edit2 > ${VCF_FOLDER}/tmp 
	mv ${VCF_FOLDER}/tmp ${VCF_FOLDER}/Manta_body_edit2
fi
done

cat ${VCF_FOLDER}/Manta_header ${VCF_FOLDER}/Manta_body_edit2 > ${VCF_FOLDER}/raw.initial3.vcf

module purge
module load BCFtools/1.9-intel-2018b
bcftools sort -Ov -o ${VCF_FOLDER}/raw.initial3.sorted.vcf ${VCF_FOLDER}/raw.initial3.vcf ;

#filter out TRA & BND
bcftools filter -i'INFO/SVTYPE!="TRA" & INFO/SVTYPE!="BND"' -o ${VCF_FOLDER}/raw_sorted.noTRA.vcf -Ov ${VCF_FOLDER}/raw.initial3.sorted.vcf
#grep -v ^\#\# $VCF_FOLDER/raw_sorted.noTRA.vcf | head
echo "total number of SVs restricted to INS, DEL, INV, DUP"
grep -v "#" ${VCF_FOLDER}/raw_sorted.noTRA.vcf | wc -l 

#filter vcf -i (include, -O vcf format -o
bcftools filter -i'INFO/SVLEN>=50 | INFO/SVLEN<=-50' -o ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf -Ov ${VCF_FOLDER}/raw_sorted.noTRA.vcf
echo "total number of SVs > 50b"
grep -v "#" ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf | wc -l 

#then we use the reference to get the sequence with a R scripts graciously provided by Marc-AndrÃ© Lemay
module purge
module load R/4.1.0-foss-2021a
Rscript ${RScripts}/add_explicit_seq_manta.r ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf ${RefFasta}

module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0
#Export sequences for advanced filtering
bcftools query -f '%CHROM %POS %INFO/END %INFO/SVTYPE %INFO/SVLEN %REF %ALT\n' ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf > ${VCF_FOLDER}/SV_data_with_seq.txt

#blacklist because of N string > 10 (possible junction of contigs 
grep -P "N{10,}" ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{print $1 "\t" $2 "\t" $6 "\t" $7}' > ${VCF_FOLDER}/N10_blacklist.bed
echo "SVs excluded because of >10N" 
wc -l ${VCF_FOLDER}/N10_blacklist.bed 

#blacklist because missing seq
cat ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{if ($6 == "N") print $1 "\t" $2 "\t" $6 "\t" $7;}' > ${VCF_FOLDER}/N_blacklist.bed
echo "SVs excluded because absence of sequence ref" 
wc -l ${VCF_FOLDER}/N_blacklist.bed 

#blacklist because missing seq
cat  ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{print $1 "\t" $2 "\t" $6 "\t" $7}' | grep -P "<" > ${VCF_FOLDER}/N_blacklist_bis.bed
echo "SVs excluded because absence of sequence alt" 
wc -l ${VCF_FOLDER}/N_blacklist_bis.bed 

#full blacklist
cat ${VCF_FOLDER}/N_blacklist.bed ${VCF_FOLDER}/N_blacklist_bis.bed ${VCF_FOLDER}/N10_blacklist.bed | sort -k1,1 -k2,2n > ${VCF_FOLDER}/blacklist.bed
#head $VCF_FOLDER/blacklist.bed
bgzip -c ${VCF_FOLDER}/blacklist.bed > ${VCF_FOLDER}/blacklist.bed.gz
tabix -s1 -b2 -e2 ${VCF_FOLDER}/blacklist.bed.gz

#remove blacklist of variants
bcftools view -T ^${VCF_FOLDER}/blacklist.bed.gz ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf > ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf
echo "SVs after filtration for N seq" 
grep -v "#" ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf | wc -l 

#sort
bcftools sort -o ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.sorted.vcf -Ov ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf

#keep the filtered vcf
cp ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.sorted.vcf ${OUTPUT_VCF}
bgzip -c ${OUTPUT_VCF} > ${OUTPUT_VCF}.gz
tabix ${OUTPUT_VCF}.gz

```

Smoove

```bash
mkdir Smoove
cd Smoove

sbatch Smoove.sh

```

Smoove.sh

```bash

module load Miniconda3/4.9.2

conda activate miniconda3_envs/smoove

mkdir tmp
export TMPDIR=SV_Merot/Smoove/tmp

smoove call -x --name SPI_BJO_ROS --fasta ../Ref/Puffin_ReferenceGenome.NU.MT.fasta -p 18 \
--genotype --duphold ../Bams/Realigned/Clipped/*.Puffin_ReferenceGenome.NU.MT.no_overlap.bam

rm -r tmp

```

Filter Smoove

```bash
gunzip SPI_BJO_ROS-smoove.genotyped.vcf.gz 
cp SPI_BJO_ROS-smoove.genotyped.vcf smoove_merged.vcf

echo "nb of SV detected by Smoove"
grep -v "#" smoove_merged.vcf | wc -l 

module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

bgzip smoove_merged.vcf

#Filter by developers
bcftools view -i '(SVTYPE = "DEL" & FMT/DHFFC[0] < 0.7) | (SVTYPE = "DUP" & FMT/DHBFC[0] > 1.3) | (SVTYPE = "INV") | (SVTYPE = "INS")' -O z -o smoove_merged.filter1.vcf.gz smoove_merged.vcf.gz
bcftools sort -O z -o smoove_merged.filter1.sorted.vcf.gz smoove_merged.filter1.vcf.gz ;

zcat smoove_merged.filter1.sorted.vcf.gz | grep -v "#" | wc -l 

INPUT_VCF=smoove_merged.filter1.sorted.vcf.gz  # we will try not to modify this one
VCF_FOLDER=TMP_VCF
OUTPUT_VCF=SPI_BJO_ROS_smoove.vcf
RScripts=SV_Merot/Rscripts
RefFasta=SV_Merot/Ref/Puffin_ReferenceGenome.NU.MT.fasta

mkdir ${VCF_FOLDER}
cp $INPUT_VCF ${VCF_FOLDER}/raw.vcf.gz
gunzip ${VCF_FOLDER}/raw.vcf.gz

#filter vcf -i (include, -O vcf format -o
bcftools filter -i'INFO/SVLEN>=50 | INFO/SVLEN<=-50' -o ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf -Ov ${VCF_FOLDER}/raw.vcf
echo "total number of SVs > 50b"
grep -v "#" ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf | wc -l #2,141

#then we use the reference to get the sequence with a R scripts graciously provided by Marc-AndrÃ© Lemay
module purge
module load R/4.1.0-foss-2021a
Rscript ${RScripts}/add_explicit_seq.r ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf ${RefFasta}

module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0
#Export sequences for advanced filtering
bcftools query -f '%CHROM %POS %INFO/END %INFO/SVTYPE %INFO/SVLEN %REF %ALT\n' ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf > ${VCF_FOLDER}/SV_data_with_seq.txt

#blacklist because of N string > 10 (possible junction of contigs 
grep -P "N{10,}" ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{print $1 "\t" $2 "\t" $6 "\t" $7}' > ${VCF_FOLDER}/N10_blacklist.bed
echo "SVs excluded because of >10N" 
wc -l ${VCF_FOLDER}/N10_blacklist.bed 

#blacklist because missing seq
cat ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{if ($6 == "N") print $1 "\t" $2 "\t" $6 "\t" $7;}' > ${VCF_FOLDER}/N_blacklist.bed
echo "SVs excluded because absence of sequence ref" 
wc -l ${VCF_FOLDER}/N_blacklist.bed 

#blacklist because missing seq
cat  ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{print $1 "\t" $2 "\t" $6 "\t" $7}' | grep -P "<" > ${VCF_FOLDER}/N_blacklist_bis.bed
echo "SVs excluded because absence of sequence alt" 
wc -l ${VCF_FOLDER}/N_blacklist_bis.bed 

#full blacklist
cat ${VCF_FOLDER}/N_blacklist.bed ${VCF_FOLDER}/N_blacklist_bis.bed ${VCF_FOLDER}/N10_blacklist.bed | sort -k1,1 -k2,2n > ${VCF_FOLDER}/blacklist.bed
#head $VCF_FOLDER/blacklist.bed
bgzip -c ${VCF_FOLDER}/blacklist.bed > ${VCF_FOLDER}/blacklist.bed.gz
tabix -s1 -b2 -e2 ${VCF_FOLDER}/blacklist.bed.gz

#remove blacklist of variants
bcftools view -T ^${VCF_FOLDER}/blacklist.bed.gz ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf > ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf
echo "SVs after filtration for N seq" 
grep -v "#" ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf | wc -l 

#keep the filtered vcf
cp ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf ${OUTPUT_VCF}
bgzip -c ${OUTPUT_VCF} > ${OUTPUT_VCF}.gz
tabix ${OUTPUT_VCF}.gz

```

GRIDSS

```bash

mkdir Gridss
cd Gridss

#setupreference
module purge
module load Miniconda3/4.9.2
conda activate miniconda3_envs/gridss

gridss \
-j Programs/gridss/gridss-2.12.2-gridss-jar-with-dependencies.jar \
-r ../Ref/Puffin_ReferenceGenome.NU.MT.FINAL.fasta \
-s setupreference

conda deactivate

cat ../samples | while read line ;
do echo ${line} ;
sbatch Gridss1.sh ${line} ;
done

```

Gridss1.sh

```bash

module load Miniconda3/4.9.2
conda activate miniconda3_envs/gridss

gridss \
-j Programs/gridss/gridss-2.12.2-gridss-jar-with-dependencies.jar \
-r ../Ref/Puffin_ReferenceGenome.NU.MT.FINAL.fasta \
-s preprocess \
-t 4 \
../Bams/NotRealigned/Clipped/${1}.Puffin_ReferenceGenome.NU.MT.no_overlap.bam

```

```bash

for i in {0..17} ;
do echo ${i} ;
sbatch Gridss2.sh ${i} ;
done

```

Gridss2.sh

```bash

module load Miniconda3/4.9.2
conda activate miniconda3_envs/gridss

gridss \
-j Programs/gridss/gridss-2.12.2-gridss-jar-with-dependencies.jar \
-r ../Ref/Puffin_ReferenceGenome.NU.MT.FINAL.fasta \
-t 8 \
-s assemble \
-a SPI_BJO_ROS_assembly.bam \
--jobnodes 18 \
--jobindex ${1} \
../Bams/NotRealigned/Clipped/BJO001.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/BJO003.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/BJO005.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/BJO006.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/BJO007.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/BJO008.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS001.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS002.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS003.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS006.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS007.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS008.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI001.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI002.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI003.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI004.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI011.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI015.Puffin_ReferenceGenome.NU.MT.no_overlap.bam
```

```bash

sbatch Gridss3.sh

```

Gridss3.sh

```bash

module load Miniconda3/4.9.2
conda activate miniconda3_envs/gridss

gridss \
-j Programs/gridss/gridss-2.12.2-gridss-jar-with-dependencies.jar \
-r ../Ref/Puffin_ReferenceGenome.NU.MT.FINAL.fasta \
-t 8 \
-s assemble,call \
-a SPI_BJO_ROS_assembly.bam \
-o SPI_BJO_ROS.vcf \
../Bams/NotRealigned/Clipped/BJO001.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/BJO003.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/BJO005.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/BJO006.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/BJO007.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/BJO008.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS001.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS002.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS003.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS006.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS007.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/ROS008.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI001.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI002.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI003.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI004.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI011.Puffin_ReferenceGenome.NU.MT.no_overlap.bam \
../Bams/NotRealigned/Clipped/SPI015.Puffin_ReferenceGenome.NU.MT.no_overlap.bam

```

FilterGridss

```bash

module purge
module load BCFtools/1.9-intel-2018b
bcftools reheader -s ../samples -o Gridss.SPI_BJO_ROS.vcf SPI_BJO_ROS.vcf
bgzip Gridss.SPI_BJO_ROS.vcf
rm SPI_BJO_ROS.vcf

zcat Gridss.SPI_BJO_ROS.vcf.gz | grep -v "#" | wc -l


#based on sv-caller github
bcftools filter -Ov -o Gridss.SPI_BJO_ROS.filter.vcf -i "FILTER == 'PASS'" Gridss.SPI_BJO_ROS.vcf.gz

cat Gridss.SPI_BJO_ROS.filter.vcf | grep -v "#" | wc -l


# Gridss files need to be converted because they only contain BND types. 

#run simple-event-annotation.R # create DUP, INV, TRANS, DEL, INS


gzip Gridss.SPI_BJO_ROS.filter.vcf 
mv Gridss.SPI_BJO_ROS.vcf.gz Gridss.SPI_BJO_ROS.complex.vcf.gz

module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

INPUT_VCF=Gridss.SPI_BJO_ROS.filter.annotated.vcf  # we will try not to modify this one
VCF_FOLDER=TMP_VCF
OUTPUT_VCF=SPI_BJO_ROS_gridss.vcf
RScripts=SV_Merot/Rscripts
RefFasta=SV_Merot/Ref/Puffin_ReferenceGenome.NU.MT.FINAL.fasta

mkdir ${VCF_FOLDER}
cp $INPUT_VCF ${VCF_FOLDER}/raw.vcf
cp Gridss.SPI_BJO_ROS.simple_edit.bed ${VCF_FOLDER}/raw.bed

echo "total number of SVs restricted to INS, DEL, INV, DUP"
wc -l ${VCF_FOLDER}/raw.bed 

#make new vcf
grep "#" ${VCF_FOLDER}/raw.vcf > ${VCF_FOLDER}/Gridss_header
zcat Gridss.SPI_BJO_ROS.filter.vcf.gz | grep -v "#" > ${VCF_FOLDER}/Gridss_body

#get the original info and make vcf
touch ${VCF_FOLDER}/Gridss_body_edit
cat ${VCF_FOLDER}/raw.bed | while read line ;
do Chr=$(echo ${line} | cut -d " " -f1) ;
Pos=$(echo ${line} | cut -d " " -f2) ;
Qual=$(echo ${line} | cut -d " " -f5) ;
cat ${VCF_FOLDER}/Gridss_body | awk -v chr=${Chr} -v start=${Pos} -v qual=${Qual} '( $1==chr && $2==start && $6==qual )' >> ${VCF_FOLDER}/Gridss_body_edit
done
cat ${VCF_FOLDER}/Gridss_header ${VCF_FOLDER}/Gridss_body_edit > ${VCF_FOLDER}/raw.init.vcf
grep -v "#" ${VCF_FOLDER}/raw.init.vcf |Â wc -l


#update svtype and length (and Ref)
module purge
module load BEDTools/2.30.0-GCC-10.2.0

cat ${VCF_FOLDER}/raw.bed | while read line ;
do Chr=$(echo ${line} | cut -d " " -f1) ;
Pos=$(echo ${line} | cut -d " " -f2) ;
End=$(echo ${line} | cut -d " " -f3) ;
Type=$(echo ${line} | cut -d " " -f4) ;
Length=$(bc <<<"scale=1; ${End} - ${Pos} - 1") ;
Start=$(bc <<<"scale=1; ${Pos} - 1") ;
echo -e "${Chr}\t${Start}\t${Pos}" > ${VCF_FOLDER}/test.bed
Ref=$(bedtools getfasta -fi ${RefFasta} -bed ${VCF_FOLDER}/test.bed | grep -v ">")
echo -e "${Chr}\t${Pos}\t${Ref}\t${Length}\t${Type}" >> ${VCF_FOLDER}/raw.noTRA.info.annot
done

module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

cp ${VCF_FOLDER}/raw.noTRA.info.annot ${VCF_FOLDER}/raw_sorted.noTRA.info.annot
bgzip ${VCF_FOLDER}/raw_sorted.noTRA.info.annot #pos to be annotated -> chr pos length (can have type too)
tabix -s1 -b2 -e2 ${VCF_FOLDER}/raw_sorted.noTRA.info.annot.gz

#step3 prepare the header
echo -e '##INFO=<ID=SVLEN,Number=.,Type=Integer,Description="Difference in length between REF and ALT alleles">' > ${VCF_FOLDER}/raw_sorted.noTRA.info.annot.hdr
echo -e '##INFO=<ID=SVTYPE,Number=.,Type=String,Description="Type of structural variant">' >> ${VCF_FOLDER}/raw_sorted.noTRA.info.annot.hdr

##step4 run bcftools annotate
#-a is the annotation file (tabix and bgzip, it needs at least CHROM and POS, -h are the header lines to add, -c are the meaning of the column in the annotation file
bcftools annotate -x REF,ALT,INFO/SVLEN,INFO/SVTYPE ${VCF_FOLDER}/raw.init.vcf > ${VCF_FOLDER}/raw.init.edit.vcf # Remove all INFO/Length fields
#doesn't actually remove ref or alt
bcftools annotate -a ${VCF_FOLDER}/raw_sorted.noTRA.info.annot.gz -h ${VCF_FOLDER}/raw_sorted.noTRA.info.annot.hdr -c CHROM,POS,-,INFO/SVLEN,INFO/SVTYPE ${VCF_FOLDER}/raw.init.edit.vcf > ${VCF_FOLDER}/raw_sorted.noTRA_bis.vcf

#need to check correctness of Ref base
bcftools norm -c w -c s -f ${RefFasta} -Ov -o ${VCF_FOLDER}/raw_sorted.noTRA_bis.fixed.vcf ${VCF_FOLDER}/raw_sorted.noTRA_bis.vcf 


#alt seq will be added with script except INS
#Keep INS and add the sequence of INS
bcftools filter -i 'INFO/SVTYPE=="INS"' -o ${VCF_FOLDER}/raw_sorted.noTRA_bis.INS.vcf -Ov ${VCF_FOLDER}/raw_sorted.noTRA_bis.vcf 
bcftools filter -i 'INFO/SVTYPE!="INS"' -o ${VCF_FOLDER}/raw_sorted.noTRA_bis.noINS.vcf -Ov ${VCF_FOLDER}/raw_sorted.noTRA_bis.vcf 

grep -v "#" ${VCF_FOLDER}/raw_sorted.noTRA_bis.INS.vcf | wc -l
grep "#" ${VCF_FOLDER}/raw_sorted.noTRA_bis.INS.vcf > ${VCF_FOLDER}/header
grep -v "#" ${VCF_FOLDER}/raw_sorted.noTRA_bis.INS.vcf > ${VCF_FOLDER}/body

#update alt
cat ${VCF_FOLDER}/body | while read line ;
do echo ${line} | cut -d " " -f5 | awk -F'[' '{print $1}' >> ${VCF_FOLDER}/Alt.seq
done
cut -f1-4 ${VCF_FOLDER}/body > ${VCF_FOLDER}/body_edit1
cut -f6- ${VCF_FOLDER}/body > ${VCF_FOLDER}/body_edit2
paste ${VCF_FOLDER}/body_edit1 ${VCF_FOLDER}/Alt.seq ${VCF_FOLDER}/body_edit2 > ${VCF_FOLDER}/body_edit
cat ${VCF_FOLDER}/header ${VCF_FOLDER}/body_edit > ${VCF_FOLDER}/raw_sorted.noTRA_bis.INS_edit.vcf

#update length
cat ${VCF_FOLDER}/body_edit | while read line ;
do Chr=$(echo ${line} | cut -d " " -f1) ;
Pos=$(echo ${line} | cut -d " " -f2) ;
Length=$(echo ${line} | cut -d " " -f5 | awk '{print length}') ;
Length_edit=$(bc <<<"scale=1; ${Length} - 1") ;
echo -e "${Chr}\t${Pos}\t${Length_edit}" >> ${VCF_FOLDER}/INS.annot.info
done
cp ${VCF_FOLDER}/INS.annot.info ${VCF_FOLDER}/INS.sorted.annot.info
bgzip ${VCF_FOLDER}/INS.sorted.annot.info #pos to be annotated -> chr pos length (can have type too)
tabix -s1 -b2 -e2 ${VCF_FOLDER}/INS.sorted.annot.info.gz
bcftools annotate -x INFO/SVLEN ${VCF_FOLDER}/raw_sorted.noTRA_bis.INS_edit.vcf > ${VCF_FOLDER}/raw_sorted.noTRA_bis.INS.edit2.vcf # Remove all INFO/Length fields

echo -e '##INFO=<ID=SVLEN,Number=.,Type=Integer,Description="Difference in length between REF and ALT alleles">' > ${VCF_FOLDER}/raw_sorted.noTRA.info.annot2.hdr
bcftools annotate -a ${VCF_FOLDER}/INS.sorted.annot.info.gz -h ${VCF_FOLDER}/raw_sorted.noTRA.info.annot2.hdr -c CHROM,POS,INFO/SVLEN ${VCF_FOLDER}/raw_sorted.noTRA_bis.INS.edit2.vcf > ${VCF_FOLDER}/raw_sorted.noTRA_bis.INS.edit3.vcf

cat ${VCF_FOLDER}/raw_sorted.noTRA_bis.INS.edit3.vcf | grep "#" > ${VCF_FOLDER}/header
cat ${VCF_FOLDER}/raw_sorted.noTRA_bis.INS.edit3.vcf | grep -v "#" > ${VCF_FOLDER}/body1
cat ${VCF_FOLDER}/raw_sorted.noTRA_bis.noINS.vcf | grep -v "#" > ${VCF_FOLDER}/body2

cat ${VCF_FOLDER}/header ${VCF_FOLDER}/body1 ${VCF_FOLDER}/body2 > ${VCF_FOLDER}/Edited.vcf
bcftools sort -o ${VCF_FOLDER}/Edited.sorted.vcf -Ov ${VCF_FOLDER}/Edited.vcf

cat ${VCF_FOLDER}/Edited.sorted.vcf | grep -v "#" | wc -l

#add INFO/END
cat ${VCF_FOLDER}/raw.bed | while read line ;
do Chr=$(echo ${line} | cut -d " " -f1) ;
Pos=$(echo ${line} | cut -d " " -f2) ;
End=$(echo ${line} | cut -d " " -f3) ;
echo -e "${Chr}\t${Pos}\t${End}" >> ${VCF_FOLDER}/raw.noTRA.End.info.annot
done
bgzip ${VCF_FOLDER}/raw.noTRA.End.info.annot #pos to be annotated -> chr pos length (can have type too)
tabix -s1 -b2 -e2 ${VCF_FOLDER}/raw.noTRA.End.info.annot.gz
echo -e '##INFO=<ID=END,Number=.,Type=Integer,Description="End Position of SV">' > ${VCF_FOLDER}/raw.noTRA.End.info.annot2.hdr
bcftools annotate -a ${VCF_FOLDER}/raw.noTRA.End.info.annot.gz -h ${VCF_FOLDER}/raw.noTRA.End.info.annot2.hdr -c CHROM,POS,INFO/END ${VCF_FOLDER}/Edited.sorted.vcf  > ${VCF_FOLDER}/Edited2.sorted.vcf 

```

```bash
#Continue with filters

#filter vcf -i (include, -O vcf format -o
bcftools filter -i'INFO/SVLEN>=50 | INFO/SVLEN<=-50' -o ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf -Ov ${VCF_FOLDER}/Edited2.sorted.vcf 

echo "total number of SVs > 50b"
grep -v "#" ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf | wc -l 


#then we use the reference to get the sequence with a R scripts graciously provided by Marc-AndrÃ© Lemay
module purge
module load R/4.1.0-foss-2021a
Rscript ${RScripts}/add_explicit_seq.r ${VCF_FOLDER}/raw_sorted.noTRA_50bp.vcf ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf ${RefFasta}

#Export sequences for advanced filtering
module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

bcftools query -f '%CHROM %POS %INFO/END %INFO/SVTYPE %INFO/SVLEN %REF %ALT\n' ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf > ${VCF_FOLDER}/SV_data_with_seq.txt

#blacklist because of N string > 10 (possible junction of contigs 
grep -P "N{10,}" ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{print $1 "\t" $2 "\t" $6 "\t" $7}' > ${VCF_FOLDER}/N10_blacklist.bed
echo "SVs excluded because of >10N" 
wc -l ${VCF_FOLDER}/N10_blacklist.bed


#blacklist because missing seq
cat ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{if ($6 == "N") print $1 "\t" $2 "\t" $6 "\t" $7;}' > ${VCF_FOLDER}/N_blacklist.bed
echo "SVs excluded because absence of sequence ref" 
wc -l ${VCF_FOLDER}/N_blacklist.bed


#blacklist because missing seq
cat  ${VCF_FOLDER}/SV_data_with_seq.txt | awk '{print $1 "\t" $2 "\t" $6 "\t" $7}' | grep -P "<" > ${VCF_FOLDER}/N_blacklist_bis.bed
echo "SVs excluded because absence of sequence alt" 
wc -l ${VCF_FOLDER}/N_blacklist_bis.bed


#full blacklist
cat ${VCF_FOLDER}/N_blacklist.bed ${VCF_FOLDER}/N_blacklist_bis.bed ${VCF_FOLDER}/N10_blacklist.bed | sort -k1,1 -k2,2n > ${VCF_FOLDER}/blacklist.bed

#head $VCF_FOLDER/blacklist.bed
bgzip -c ${VCF_FOLDER}/blacklist.bed > ${VCF_FOLDER}/blacklist.bed.gz
tabix -s1 -b2 -e2 ${VCF_FOLDER}/blacklist.bed.gz

#remove blacklist of variants
bcftools view -T ^${VCF_FOLDER}/blacklist.bed.gz ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ.vcf > ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf
echo "SVs after filtration for N seq" 
grep -v "#" ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf | wc -l


#keep the filtered vcf
cp ${VCF_FOLDER}/raw_sorted.noTRA_50bp_withSEQ_Nfiltered.vcf ${OUTPUT_VCF}
bgzip -c ${OUTPUT_VCF} > ${OUTPUT_VCF}.gz
tabix ${OUTPUT_VCF}.gz

```

Jasmine 

```bash

mkdir Jasmine

cd Jasmine

cp ../Delly/SPI_BJO_ROS_delly.vcf.gz .

cp ../Manta/SPI_BJO_ROS_manta.vcf.gz .

cp ../Smoove/SPI_BJO_ROS_smoove.vcf.gz .

cp ../Gridss/SPI_BJO_ROS_gridss.vcf.gz .

gunzip *.gz

ls *.vcf > Manta_Smoove_Delly_Gridss.list

```

Jasmine.sh

```bash

module load Miniconda3/4.9.2
conda activate miniconda3_envs/jasmine

module purge
module load BCFtools/1.9-intel-2018b
module load SAMtools/1.9-GCC-7.3.0-2.30


#input a list of vcf files (should not be zip)
BASE="Manta_Smoove_Delly_Gridss"

VCFlist=${BASE}.list
OUTfile=${BASE}.vcf
Ref=SV_Merot/Ref/Puffin_ReferenceGenome.NU.MT.FINAL.fasta

jasmine file_list=${VCFlist} out_file=${OUTfile} genome_file=${Ref} \
--ignore_strand --default_zero_genotype --mutual_distance \
--max_dist_linear=0.5 --max_dist=1000 --min_dist=50 --use_end \
--normalize_type --allow_intrasample threads=1

conda deactivate

```


Then

```bash
module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0
BASE="Manta_Smoove_Delly_Gridss"
VCFlist=${BASE}.list
OUTfile=${BASE}.vcf
Ref=SV_Merot/Ref/Puffin_ReferenceGenome.NU.MT.FINAL.fasta

bcftools query -f '%CHROM %POS %INFO/END %INFO/SVTYPE %INFO/SVLEN %INFO/SUPP_VEC %INFO/SUPP\n' ${OUTfile} > ${BASE}.bed

echo "nb of SV"
grep -v "#" ${BASE}.vcf | wc -l 

perl -ne 'print "$1\n" if /SUPP_VEC=([^,;]+)/' ${BASE}.vcf | sed -e 's/\(.\)/\1 /g' > ${BASE}.overlap.txt

#remove the ones on Unplaced (no validity) and W (only covered on half) and MT and Z
vcftools --vcf ${BASE}.vcf \
--not-chr Chr_W \
--not-chr Chr_Unplaced  \
--not-chr Chr_MT \
--not-chr Chr_Z \
--remove-filtered-all --recode --recode-INFO-all --stdout | gzip > ${BASE}.Autosomes.vcf.gz

mv out.log Autosomes.log

zcat ${BASE}.Autosomes.vcf.gz | grep -v "#" | wc -l


gunzip ${BASE}.Autosomes.vcf.gz
#Venn for all
perl -ne 'print "$1\n" if /SUPP_VEC=([^,;]+)/' ${BASE}.Autosomes.vcf  | sed -e 's/\(.\)/\1 /g' > ${BASE}.Autosomes.overlap.txt
#Venn for each SVType
for i in INV DUP INS DEL ;
do echo $i ;
grep -v "#" ${BASE}.Autosomes.vcf | grep "SVTYPE=${i}" | perl -ne 'print "$1\n" if /SUPP_VEC=([^,;]+)/' - | sed -e 's/\(.\)/\1 /g' > ${BASE}.Autosomes.${i}.overlap.txt ;
done

ls *overlap.txt | while read line ;
do echo $line ;
wc -l $line ;
done


#Saga
bcftools filter -i'INFO/SUPP!="1"' -o ${BASE}.Autosomes_min2tools.vcf -Ov ${BASE}.Autosomes.vcf

echo "nb of SV with at least 2 tools"
grep -v "#" ${BASE}.Autosomes_min2tools.vcf | wc -l 

##MAKING SV DISTRIBUTION##
touch Manta_Smoove_Delly_Gridss.Autosomes_min2tools.SVDistr
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_min2tools.vcf | while read line ;
do Chromo=$(echo $line | cut -d ' ' -f1) ;
Start=$(echo $line | cut -d ' ' -f2) ;
End=$(echo $line | cut -d ' ' -f8 | awk -F 'END=' '{print $2}' | awk -F ';' '{print $1}') ;
Type=$(echo $line | cut -d ' ' -f8 | awk -F 'SVTYPE=' '{print $2}' | awk -F ';' '{print $1}') ;
Length=$(echo $line | cut -d ' ' -f8 | awk -F 'SVLEN=' '{print $2}' | awk -F ';' '{print $1}') ;
echo -e "${Chromo}\t${Start}\t${End}\t${Type}\t${Length}" >> Manta_Smoove_Delly_Gridss.Autosomes_min2tools.SVDistr ;
done
wc -l Manta_Smoove_Delly_Gridss.Autosomes_min2tools.SVDistr


grep -v "INV" Manta_Smoove_Delly_Gridss.Autosomes_min2tools.SVDistr > new1
rm Manta_Smoove_Delly_Gridss.Autosomes_min2tools.SVDistr

touch new2
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_min2tools.vcf | grep "SVTYPE=INV" | while read line ;
do Chromo=$(echo $line | cut -d ' ' -f1) ;
Start=$(echo $line | cut -d ' ' -f2) ;
Length=$(echo ${line} | cut -d " " -f4 | awk '{print length}') ;
Length_edit=$(bc <<<"scale=1; ${Length} - 1") ;
End=$(bc <<<"scale=1; ${Start} + ${Length_edit}") ;
Type=INV ;
echo -e "${Chromo}\t${Start}\t${End}\t${Type}\t${Length_edit}" >> new2 ;
done
wc -l new2


cat new1 new2 > new3
sort -k1,1 -k2,2n new3 > Manta_Smoove_Delly_Gridss.Autosomes_min2tools.SVDistr
wc -l Manta_Smoove_Delly_Gridss.Autosomes_min2tools.SVDistr

rm new*

```

VG

```bash


mkdir VG

cd VG

module purge
module load BCFtools/1.9-intel-2018b
module load SAMtools/1.9-GCC-7.3.0-2.30

BASE="Manta_Smoove_Delly_Gridss.Autosomes"

cp ../Jasmine/${BASE}_min2tools.vcf . 

VCF_file=${BASE}_min2tools.vcf

grep -v "#" ${VCF_file} | wc -l

grep "SVTYPE=INV" ${VCF_file} | wc -l

grep "SVTYPE=INS" ${VCF_file} | wc -l

grep "SVTYPE=DEL" ${VCF_file} | wc -l

grep "SVTYPE=DUP" ${VCF_file} | wc -l


#again header is missing information.
#we extract it and edit manually
grep "#" ${VCF_file} > header

cat header | grep "##INFO=" >> header.info
cat ../Jasmine/SPI_BJO_ROS_delly.vcf | grep "##INFO" >> header.info
cat ../Jasmine/SPI_BJO_ROS_smoove.vcf | grep "##INFO" >> header.info
cat ../Jasmine/SPI_BJO_ROS_gridss.vcf | grep "##INFO" >> header.info
cat ../Jasmine/SPI_BJO_ROS_manta.vcf | grep "##INFO" >> header.info
sort header.info | uniq >> header.info.edit
cat header.info.edit

cp header header_corrected

nano header_corrected

```

Then

```bash
BASE="Manta_Smoove_Delly_Gridss.Autosomes"
VCF_file=${BASE}_min2tools.vcf
module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

(cat header_corrected; grep -v "#" ${VCF_file} | sort -k1,1 -k2,2n) > ${BASE}_sorted.vcf

bcftools sort -o ${BASE}_sorted_noind.vcf -Ov ${BASE}_sorted.vcf

grep -v "##" ${BASE}_sorted_noind.vcf > body
grep "##" ${BASE}_sorted_noind.vcf > header_new
nano header_new
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">

cut -f1-8 body > body1
wc -l body1
echo -e "FORMAT\tDummy" >> body2
for i in {1..14525} ;
do
echo -e "GT\t0/0" >> body2 ;
done

paste body1 body2 > body_new

cat header_new body_new > ${BASE}_sorted_noind.edit.vcf

bgzip -c ${BASE}_sorted_noind.edit.vcf > ${BASE}_sorted_noind.edit.vcf.gz
tabix ${BASE}_sorted_noind.edit.vcf.gz

grep "SVTYPE=INV" ${BASE}_sorted_noind.edit.vcf | wc -l

grep "SVTYPE=INS" ${BASE}_sorted_noind.edit.vcf | wc -l

grep "SVTYPE=DEL" ${BASE}_sorted_noind.edit.vcf | wc -l

grep "SVTYPE=DUP" ${BASE}_sorted_noind.edit.vcf | wc -l


```

VG_index.sh

```bash

module purge

module load Miniconda3/4.9.2
conda activate miniconda3_envs/vg

# Creating some variables for easier scripting
Ref=SV_Merot/Ref/Puffin_ReferenceGenome.NU.MT.FINAL.fasta
vcf_file=Manta_Smoove_Delly_Gridss.Autosomes_sorted_noind.edit.vcf.gz

mkdir TMPDIR

vg autoindex --workflow giraffe \
--prefix vcf_graph_giraffe \
--tmp-dir TMPDIR \
--target-mem 190G --threads 8 \
-R XG \
--ref-fasta ${Ref} \
--vcf ${vcf_file}

mkdir Graph
mv vcf* Graph/


```

VG_pack.sh

```bash
#GET FASTQ PER R1 and R2 PER Sample
mkdir SequencingData
cd SequencingData
cp Paleomix/MappingContactZone/Hybrid.samples .
cp Paleomix/MappingContactZone/*.yaml .

ls *.yaml | while read yaml ;
do echo ${yaml} ;
grep "/cluster/work/users/oliverke" ${yaml} | while read file ;
do file_new=$(echo ${file} | awk -F': ' '{print $2}' | sed 's/{Pair}/*/g') ;
cp ${file_new} . ;
done ;
done ;

rm *.yaml


cat Hybrid.samples | while read sample ;
do echo ${sample} ;
zcat *-${sample}_*_R1_001.fastq.gz > ${sample}.R1.fastq ;
zcat *-${sample}_*_R2_001.fastq.gz > ${sample}.R2.fastq ;
rm *-${sample}_*_001.fastq.gz ;
done ;

#TRIM THEM WITH ADAPTERREMOVAL
module purge
module load AdapterRemoval/2.3.1-GCC-8.2.0-2.31.1

cat Hybrid.samples | while read sample ;
do echo ${sample} ;
AdapterRemoval \
--file1 ${sample}.R1.fastq \
--file2 ${sample}.R2.fastq \
--adapter1 AGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG \
--adapter2 AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGTNNNNNNNNGTGTAGATCTCGGTGGTCGCCGTATCATT \
--trimns --trimqualities \
--threads 4 --basename ${sample}.trimmed ;
done ;

cat Hybrid.samples | while read sample ;
do echo ${sample} ;
mv ${sample}.trimmed.pair1.truncated ${sample}.trimmed.R1.fastq
mv ${sample}.trimmed.pair2.truncated ${sample}.trimmed.R2.fastq
gzip ${sample}.trimmed.R1.fastq
gzip ${sample}.trimmed.R2.fastq
rm ${sample}.R*.fastq ;
rm ${sample}.trimmed.discarded
rm ${sample}.trimmed.settings
rm ${sample}.trimmed.singleton.truncated
done

cd VG
cp ../SequencingData/Hybrid.samples .

mkdir Alignment

cat Hybrid.samples | while read sample ;
do echo ${sample} ;
sbatch GiraffeMap.sh ${sample} ;
done

```

GiraffeMap.sh

```bash

module load Miniconda3/4.9.2
conda activate miniconda3_envs/vg

module load HTSlib/1.9-intel-2018b

Threads=4

# Creating variables for the location of the input files
fq1=/cluster/work/users/oliverke/HighCov/NucAnalysis/SV_Merot/SequencingData/${1}.trimmed.R1.fastq.gz
fq2=/cluster/work/users/oliverke/HighCov/NucAnalysis/SV_Merot/SequencingData/${1}.trimmed.R2.fastq.gz


vg giraffe -t ${Threads} \
-Z Graph/vcf_graph_giraffe.giraffe.gbz \
-m Graph/vcf_graph_giraffe.min \
-d Graph/vcf_graph_giraffe.dist \
-f $fq1 -f $fq2 -N ${1} > Alignment/${1}_paired.gam

# -Q 5: ignore mapping and base qualitiy < 5
vg pack -t ${Threads} -Q 5 -x Graph/vcf_graph_giraffe.xg -g Alignment/${1}_paired.gam -o Alignment/${1}.pack

```

VG_call.sh

```bash

cd VG

mkdir Variants

module purge
module load Miniconda3/4.9.2

conda activate miniconda3_envs/vg

module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

#prepare
ref=SV_Merot/Ref/Puffin_ReferenceGenome.NU.MT.FINAL.fasta
graph=Graph/vcf_graph_giraffe.xg
snarls=Graph/vcf_graph_giraffe.pb
vcf=SV_Merot/VG/Manta_Smoove_Delly_Gridss.Autosomes_sorted_noind.edit.vcf.gz
Threads=6

#get the snarls
vg snarls -t ${Threads} ${graph} > ${snarls}

conda deactivate

cat Hybrid.samples | while read sample ;
do echo ${sample} ;
sbatch VGcall_filter.sh ${sample} ;
done

```

VGcall_filter.sh

```bash


module load Miniconda3/4.9.2
conda activate miniconda3_envs/vg

# Loading the htslib module and creating variables for easier scripting
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

#prepare
ref=SV_Merot/Ref/Puffin_ReferenceGenome.NU.MT.FINAL.fasta
graph=Graph/vcf_graph_giraffe.xg
snarls=Graph/vcf_graph_giraffe.pb
vcf=SV_Merot/VG/Manta_Smoove_Delly_Gridss.Autosomes_sorted_noind.edit.vcf.gz
Threads=6

echo ${1}

# Calling variants based on the variant-aware graph
##the a option compute genotype for all snarls (not only not-ref)
##we have compute the snarls for all samples once earlier to make it faster
vg call -t ${Threads} -a -k Alignment/${1}.pack -r ${snarls} -f ${ref} -s ${1} ${graph} > Variants/${1}_calls.vcf
bgzip Variants/${1}_calls.vcf

echo ${1} > Variants/${1}_temp.txt
bcftools reheader -s Variants/${1}_temp.txt -o Variants/${1}_calls_renamed.vcf.gz Variants/${1}_calls.vcf.gz

#count variants
zcat Variants/${1}_calls_renamed.vcf.gz | grep -v "#"  | wc -l 


#Filtering based on depth
bcftools filter -e 'INFO/DP<1' -o Variants/${1}_DP1.vcf -Ov Variants/${1}_calls_renamed.vcf.gz
grep -v "#" Variants/${1}_DP1.vcf | wc -l 


bgzip -c Variants/${1}_DP1.vcf > Variants/${1}_DP1.vcf.gz
tabix Variants/${1}_DP1.vcf.gz

#unfiltered
cp Variants/${1}_calls_renamed.vcf.gz Variants/${1}_unfiltered.vcf.gz 
zcat Variants/${1}_unfiltered.vcf.gz | grep -v "#" | wc -l 


tabix Variants/${1}_unfiltered.vcf.gz

```

VG_merge+Filter

```bash

module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

#it reorders samples by alphabetical order at the same time
#bcftools merge $(ls 07_variants/*_filter.vcf.gz) -o 09_vgiraffe/vcf_graph/all_samples_filter.vcf -Ov
bcftools merge $(ls Variants/*_DP1.vcf.gz) -o Variants/All_samples_DP1.vcf -Ov
bcftools merge $(ls Variants/*_unfiltered.vcf.gz) -o Variants/All_samples_unfiltered.vcf -Ov

#which vcf to work with?
VCF_BASE=All_samples_DP1

#how many variants?
grep -v "#" Variants/${VCF_BASE}.vcf | wc -l  


#we use bcftools to add some tags (MAF, NS, etc)
bcftools +fill-tags Variants/${VCF_BASE}.vcf -o Variants/${VCF_BASE}_tag.vcf -Ov

#filter for genotyped in >50% of samples
bcftools filter -i'INFO/NS>=9' -o Variants/${VCF_BASE}_MISS50.vcf -Ov Variants/${VCF_BASE}_tag.vcf 
grep -v "#" Variants/${VCF_BASE}_MISS50.vcf | wc -l 

#filter for SVs with only 2 alleles 
bcftools view --max-alleles 2 -o Variants/${VCF_BASE}_MISS50_2all.vcf -Ov Variants/${VCF_BASE}_MISS50.vcf
grep -v "#" Variants/${VCF_BASE}_MISS50_2all.vcf | wc -l 


#filter for maf >5% (same as only keep ones with AC > 1 (needs to be in more than 1 sample))
bcftools filter -i'INFO/MAF>=0.05' -o Variants/${VCF_BASE}_MISS50_2all_maf5.vcf -Ov Variants/${VCF_BASE}_MISS50_2all.vcf
grep -v "#" Variants/${VCF_BASE}_MISS50_2all_maf5.vcf | wc -l 


#remove monomorphics
bcftools filter -i'INFO/AC<36' -o Variants/${VCF_BASE}_MISS50_2all_maf5_ac36.vcf -Ov Variants/${VCF_BASE}_MISS50_2all_maf5.vcf
grep -v "#" Variants/${VCF_BASE}_MISS50_2all_maf5_ac36.vcf | wc -l 


#keep info about SV & extract it
bcftools query -f '%CHROM %POS %REF %ALT\n' Variants/${VCF_BASE}_MISS50_2all_maf5_ac36.vcf > Variants/${VCF_BASE}_MISS50_2all_maf5_ac36.variants
bcftools query -f '%CHROM\t%POS\n' Variants/${VCF_BASE}_MISS50_2all_maf5_ac36.vcf > Variants/${VCF_BASE}_MISS50_2all_maf5_ac36.chrpos

cd Variants
module purge
module load R/4.1.0-foss-2021a
Rscripts=SV_Merot/Rscripts

Rscript ${Rscripts}/extract_SV_info_graph.r ${VCF_BASE}_MISS50_2all_maf5_ac36.variants

cd ..
mkdir Reformat
cd Reformat
cp ../Variants/${VCF_BASE}_MISS50_2all_maf5_ac36.variants* .
cp ../Variants/${VCF_BASE}_MISS50_2all_maf5_ac36.chrpos* .
cd ..
head -n 2 Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36.variants.bed

#make VCF for downstream
grep "#" Variants/${VCF_BASE}_MISS50_2all_maf5_ac36.vcf > Reformat/header
grep -v "#" Variants/${VCF_BASE}_MISS50_2all_maf5_ac36.vcf | cut -f1-2 > Reformat/body1
cut -f4 Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36.variants.bed > Reformat/body2
grep -v "#" Variants/${VCF_BASE}_MISS50_2all_maf5_ac36.vcf | cut -f4- > Reformat/body3
paste Reformat/body1 Reformat/body2 Reformat/body3 > Reformat/body_final
cat Reformat/header Reformat/body_final > Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.vcf

#remove MT, W, Z, Unplaced
module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

vcftools --vcf Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.vcf --not-chr Chr_Z --not-chr Chr_W --not-chr Chr_MT --not-chr Chr_Unplaced --remove-filtered-all --recode --recode-INFO-all --stdout > Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.vcf
grep -v "#" Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.vcf | wc -l


cp Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.vcf  .

```

Then

```bash

#Remove related ind.
module purge
module load BCFtools/1.9-intel-2018b

bcftools view -s ^SPI002 -o ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.vcf -Ov ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.vcf
bcftools +fill-tags ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.vcf -o ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.update.vcf -Ov
bcftools view -i 'INFO/AC>0 && INFO/AC<34 ' -o ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.edit.vcf ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.update.vcf
grep -v "#" ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.edit.vcf | wc -l


mkdir SmartPCA

cd SmartPCA

cp ../${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.edit.vcf .

mv ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.edit.vcf SVs.Autosomes.NoRelate.vcf 

grep -v "#" SVs.Autosomes.NoRelate.vcf | wc -l


#GET FINAL SV INFO
module purge
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0
bcftools query -f '%CHROM\t%POS\n' SVs.Autosomes.NoRelate.vcf > SVs.Autosomes.NoRelate.vcf.chrpos
cp ../VG/Manta_Smoove_Delly_Gridss.Autosomes_sorted_noind.edit.vcf .
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_sorted_noind.edit.vcf | cut -f1-2 > part1
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_sorted_noind.edit.vcf | awk -F 'SVTYPE=' '{print $2}' | awk -F ';' '{print $1}' > part4
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_sorted_noind.edit.vcf | awk -F 'END=' '{print $2}' | awk -F ';' '{print $1}' > part2 
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_sorted_noind.edit.vcf | awk -F 'SVLEN=' '{print $2}' | awk -F ';' '{print $1}' > part3 
paste part1 part2 part3 part4 > Variants.info
wc -l Variants.info

rm part*
grep -v "INV" Variants.info > Variants.noINV.info
wc -l Variants.noINV.info

grep "INV" Variants.info > Variants.INV.info
wc -l Variants.INV.info


grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_sorted_noind.edit.vcf | grep "SVTYPE=INV" | while read line ;
do Chr=$(echo ${line} | cut -d " " -f1) ;
Pos=$(echo ${line} | cut -d " " -f2) ;
Length=$(echo ${line} | cut -d " " -f5 | awk '{print length}') ;
Length_edit=$(bc <<<"scale=1; ${Length} - 1") ;
End=$(bc <<<"scale=1; ${Pos} + ${Length_edit}") ;
echo -e "${Chr}\t${Pos}\t${End}\t${Length_edit}\tINV" >> INV.annot.info
done
wc -l INV.annot.info

cat INV.annot.info | sort | uniq > INV.annot.edit.info
wc -l INV.annot.edit.info


cat Variants.noINV.info INV.annot.info > Variants_all.info
wc -l Variants_all.info


rm SVs.Autosomes.NoRelate.vcf.EndLengthType.info

cat SVs.Autosomes.NoRelate.vcf.chrpos | while read line ;
do Chr=$(echo $line | cut -d ' ' -f1) ;
Start=$(echo $line | cut -d ' ' -f2) ;
awk -F '\t' -v chr=${Chr} -v start=${Start} '{if ($1==chr && $2==start) print $1"\t"$2"\t"$3"\t"$4"\t"$5}' Variants_all.info >> SVs.Autosomes.NoRelate.vcf.EndLengthType.info
done

cut -f1,2 SVs.Autosomes.NoRelate.vcf.chrpos | sort > test1
cut -f1,2 SVs.Autosomes.NoRelate.vcf.EndLengthType.info | sort > test2
wc -l test1

wc -l test2


comm -23 test1 test2 | wc -l

comm -23 test1 test2 > Added.variants

# some variants where added by VG suite (some are in SVs.Autosomes.NoRelate.vcf.chrpos 
# which are not in Manta_Smoove_Delly_Gridss.Autosomes_sorted_noind.edit.vcf )
# these don't show up in SVs.Autosomes.NoRelate.vcf.EndLengthType.info then)
module purge
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

bcftools query -f '%CHROM %POS %REF %ALT\n' SVs.Autosomes.NoRelate.vcf > SVs.Autosomes.NoRelate.vcf.variants

module purge
module load R/4.1.0-foss-2021a
Rscripts=SV_Merot/Rscripts
Rscript ${Rscripts}/extract_SV_info_graph.r SVs.Autosomes.NoRelate.vcf.variants

cat Added.variants | while read line ;
do Chr=$(echo $line | cut -d ' ' -f1) ;
Start=$(echo $line | cut -d ' ' -f2) ;
awk -F '\t' -v chr=${Chr} -v start=${Start} '{if ($1==chr && $2==start) print $1"\t"$2"\t"$10"\t"$12"\t"$8}' SVs.Autosomes.NoRelate.vcf.variants.info >> Added.variants.info
done
cat SVs.Autosomes.NoRelate.vcf.EndLengthType.info Added.variants.info > SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.info
wc -l SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.info


cat SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.info | sort -k1,1 -k2,2n > SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.info
awk '{if ($4 > 49 || $4 < -49) print $0}' SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.info > SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info

wc -l SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info


cat SVs.Autosomes.NoRelate.vcf | grep -v "#" | sort -k1,1 -k2,2n > body.sorted
cat SVs.Autosomes.NoRelate.vcf | grep "#" > header.sorted

cat SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info | while read line ;
do Chr=$(echo $line | cut -d ' ' -f1) ;
Start=$(echo $line | cut -d ' ' -f2) ;
awk -F '\t' -v chr=${Chr} -v start=${Start} '{if ($1==chr && $2==start) print $0}' body.sorted >> body.sorted.edit ;
done
cat header.sorted body.sorted.edit > SVs.Autosomes.NoRelate.sorted.filtered.vcf
wc -l body.sorted.edit 


rm header.sorted
rm body.sorted
rm body.sorted.edit

grep "INV" SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info | wc -l

grep "INS" SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info | wc -l

grep "DEL" SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info | wc -l

grep "DUP" SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info | wc -l


```

WITH PARAGRAPH

```bash
#SAGA
cd SV_Merot/Paragraph
cp ../Jasmine/*Autosomes_min2tools.vcf .
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_min2tools.vcf | wc -l

grep "#" Manta_Smoove_Delly_Gridss.Autosomes_min2tools.vcf > header 
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_min2tools.vcf > body

touch body_new

#the following lines convert the vcf file to the format required for paragraph
#only DEL, INV, INS, DUP
#INS have insertion sequence as alt allele, the rest has the symbol as alt. allele
#also only need first 8 columns and not actual FORMAT/Sample Info

cat body | while read line ; 
do Check=$(echo ${line} | cut -d ' ' -f1-3) ;
echo ${Check} ;
svtype=$(echo ${line} | awk -F ' ' '{print $8}' | awk -F 'SVTYPE=' '{print $2}' | cut -d ";" -f1) ;
if [[ ${svtype} = "DEL" ]] || [[ ${svtype} = "DUP" ]] 
then
	svtype_new=$(echo -e "<${svtype}>")
	echo ${line} | awk -F ' ' -v alt=${svtype_new} '{print $1"\t"$2"\t"$3"\t"$4"\t"alt"\t"$6"\t"$7"\t"$8}' >> body_new
else
	if [[ ${svtype} = "INV" ]]
	then
		svtype_new=$(echo -e "<${svtype}>")
		Pos=$(echo ${line} | cut -d ' ' -f2 )
		Length=$(echo ${line} | cut -d ' ' -f4 | awk '{print length}' ) ;
		Length_edit=$(bc <<<"scale=1; ${Length} - 1" ) ;
		End=$(bc <<<"scale=1; ${Pos} + ${Length_edit}" ) ;
		New_info1=$(echo ${line} | awk -F ' ' '{print $8}' | awk -F ';END=' '{print $1}' )
		New_info2=$(echo -e "END=${End}")
		New_info3=$(echo ${line} | awk -F ' ' '{print $8}' | awk -F ';END=' '{print $2}' | cut -d ';' -f2- )
		New_info=$(echo -e "${New_info1};${New_info2};${New_info3}")
		echo ${line} | awk -F ' ' -v alt=${svtype_new} -v info=${New_info} '{print $1"\t"$2"\t"$3"\t"$4"\t"alt"\t"$6"\t"$7"\t"info}' >> body_new
	else
		echo ${line} | awk -F ' ' '{print $1"\t"$2"\t"$3"\t"$4"\t"$5"\t"$6"\t"$7"\t"$8}' >> body_new
	fi
fi
done &> out


cp header header_corrected		
```


Then

```bash
cat header_corrected body_new > Manta_Smoove_Delly_Gridss.Autosomes_min2tools.for_paragraph.vcf

module purge
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

#Keep INS and add the sequence of INS (some gridss consensus by Jasmine doesn't have Alt seq)
bcftools filter -i 'INFO/SVTYPE=="INS"' -o INS.vcf -Ov Manta_Smoove_Delly_Gridss.Autosomes_min2tools.for_paragraph.vcf
bcftools filter -i 'INFO/SVTYPE!="INS"' -o NoINS.vcf -Ov Manta_Smoove_Delly_Gridss.Autosomes_min2tools.for_paragraph.vcf

grep -v "#" INS.vcf | grep -v "<INS>" > INS_body1
grep -v "#" INS.vcf | grep "<INS>" | while read line ;
do ID=$(echo ${line} | awk -F ' ' '{print $3}' | awk -F '_' '{print $2"_"$3}' )
new_ref=$(grep -m 1 ${ID} ../Jasmine/SPI_BJO_ROS_gridss.vcf | cut -f4) 
new_alt=$(grep -m 1 ${ID} ../Jasmine/SPI_BJO_ROS_gridss.vcf | cut -f5 | sed 's/\[.*\[//g' | sed 's/\].*\]//g')
echo ${line} | awk -F ' ' -v alt=${new_alt} -v ref=${new_ref} '{print $1"\t"$2"\t"$3"\t"ref"\t"alt"\t"$6"\t"$7"\t"$8}' >> INS_body2
done

cat NoINS.vcf INS_body1 INS_body2 > Manta_Smoove_Delly_Gridss.Autosomes_min2tools.for_paragraph.edit.vcf

bcftools sort Manta_Smoove_Delly_Gridss.Autosomes_min2tools.for_paragraph.edit.vcf > Manta_Smoove_Delly_Gridss.Autosomes_min2tools.for_paragraph.edit.sorted.vcf

cat ../samples | while read line ;
do echo ${line} ;
sbatch Paragraph.sh ${line} ;
done

cat ../samples | grep -v "BJO001" | while read line ;
do echo ${line} ;
sbatch Paragraph.sh ${line} ;
done

```

Paragraph.sh

```bash

module load Miniconda3/4.9.2
conda activate miniconda3_envs/paragraph

module load SAMtools/1.9-GCC-7.3.0-2.30

AverageReadLength=$(samtools view -F4 /cluster/work/users/oliverke/HighCov/NucAnalysis/SV_Merot/Bams/Realigned/Clipped/${1}.Puffin_ReferenceGenome.NU.MT.no_overlap.bam | awk '{print length($10)}' | awk '{ total += $1 } END { print total/NR }' | sed 's/ //g' | awk '{print int($1+0.5)}')
DepthOverall=$(samtools depth /cluster/work/users/oliverke/HighCov/NucAnalysis/SV_Merot/Bams/Realigned/Clipped/${1}.Puffin_ReferenceGenome.NU.MT.no_overlap.bam | awk '{total += $3} END {print total/NR}' | sed 's/ //g' | awk '{print int($1+0.5)}')

touch ${1}.samples.txt
echo -e "id\tpath\tread length\tdepth" >> ${1}.samples.txt
echo -e ${1}"\tSV_Merot/Bams/Realigned/Clipped/${1}.Puffin_ReferenceGenome.NU.MT.no_overlap.bam\t${AverageReadLength}\t${DepthOverall}" >> ${1}.samples.txt

#run per sample
TwentyDepth=$(bc <<<"scale=3; 20 * $DepthOverall")

mkdir ${1}.temp

miniconda3_envs/paragraph/bin/multigrmpy.py \
-i Manta_Smoove_Delly_Gridss.Autosomes_min2tools.for_paragraph.edit.sorted.vcf \
-m ${1}.samples.txt \
-o Paragraph${1} \
-r ../Ref/Puffin_ReferenceGenome.NU.MT.FINAL.fasta \
-t 4 \
-M ${TwentyDepth} \
--scratch-dir SV_Merot/Paragraph/${1}.temp \
--debug \
--logfile ${1}.paragraph.log



rm -r ${1}.temp
cd Paragraph${1}/
mv genotypes.vcf.gz ${1}.genotypes.vcf.gz
cp ${1}.genotypes.vcf.gz ../
cd ../

```

Then

```bash

#merge them
module purge
module load BCFtools/1.9-intel-2018b

touch filelist
cat ../samples | while read line ;
do echo ${line} ;
bcftools sort ${line}.genotypes.vcf.gz -O z -o ${line}.genotypes.vcf.sorted.gz ;
bcftools index ${line}.genotypes.vcf.sorted.gz ;
bcftools annotate --set-id +'%CHROM\_%POS' -O z -o ${line}.genotypes.vcf.sorted.ID.gz ${line}.genotypes.vcf.sorted.gz
bcftools index ${line}.genotypes.vcf.sorted.ID.gz ;
echo -e "${line}.genotypes.vcf.sorted.ID.gz" >> filelist ;
done

#Filtering based on depth
cat ../samples | while read line ;
do echo ${line} ;
bcftools filter -e 'FORMAT/DP<1' -o ${line}.genotypes.vcf.sorted.ID_DP1.vcf -Ov ${line}.genotypes.vcf.sorted.ID.gz
bgzip -c ${line}.genotypes.vcf.sorted.ID_DP1.vcf > ${line}.genotypes.vcf.sorted.ID_DP1.vcf.gz
tabix ${line}.genotypes.vcf.sorted.ID_DP1.vcf.gz
done

bcftools merge $(ls *_DP1.vcf.gz) -o All_samples_DP1.vcf -Ov

#which vcf to work with?
VCF_BASE=All_samples_DP1

#how many variants?
grep -v "#" ${VCF_BASE}.vcf | wc -l  


#we use bcftools to add some tags (MAF, NS, etc)
bcftools +fill-tags ${VCF_BASE}.vcf -o ${VCF_BASE}_tag.vcf -Ov

#filter for genotyped in >50% of samples
bcftools filter -i'INFO/NS>=9' -o ${VCF_BASE}_MISS50.vcf -Ov ${VCF_BASE}_tag.vcf 
grep -v "#" ${VCF_BASE}_MISS50.vcf | wc -l 


#filter for SVs with only 2 alleles 
bcftools view --max-alleles 2 -o ${VCF_BASE}_MISS50_2all.vcf -Ov ${VCF_BASE}_MISS50.vcf
grep -v "#" ${VCF_BASE}_MISS50_2all.vcf | wc -l 


#filter for maf >5% (same as only keep ones with AC > 1 (needs to be in more than 1 sample))
bcftools filter -i'INFO/MAF>=0.05' -o ${VCF_BASE}_MISS50_2all_maf5.vcf -Ov ${VCF_BASE}_MISS50_2all.vcf
grep -v "#" ${VCF_BASE}_MISS50_2all_maf5.vcf | wc -l 


#remove monomorphics
bcftools filter -i'INFO/AC<36' -o ${VCF_BASE}_MISS50_2all_maf5_ac36.vcf -Ov ${VCF_BASE}_MISS50_2all_maf5.vcf
grep -v "#" ${VCF_BASE}_MISS50_2all_maf5_ac36.vcf | wc -l 


#keep info about SV & extract it
bcftools query -f '%CHROM %POS %REF %ALT\n' ${VCF_BASE}_MISS50_2all_maf5_ac36.vcf > ${VCF_BASE}_MISS50_2all_maf5_ac36.variants
bcftools query -f '%CHROM\t%POS\n' ${VCF_BASE}_MISS50_2all_maf5_ac36.vcf > ${VCF_BASE}_MISS50_2all_maf5_ac36.chrpos

module purge
module load R/4.1.0-foss-2021a
Rscripts=SV_Merot/Rscripts

Rscript ${Rscripts}/extract_SV_info_graph.r ${VCF_BASE}_MISS50_2all_maf5_ac36.variants

mkdir Reformat
cd Reformat
cp ../${VCF_BASE}_MISS50_2all_maf5_ac36.variants* .
cp ../${VCF_BASE}_MISS50_2all_maf5_ac36.chrpos* .
cd ..
head -n 2 Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36.variants.bed

#make VCF for downstream
grep "#" ${VCF_BASE}_MISS50_2all_maf5_ac36.vcf > Reformat/header
grep -v "#" ${VCF_BASE}_MISS50_2all_maf5_ac36.vcf | cut -f1-2 > Reformat/body1
cut -f4 ${VCF_BASE}_MISS50_2all_maf5_ac36.variants.bed > Reformat/body2
grep -v "#" ${VCF_BASE}_MISS50_2all_maf5_ac36.vcf | cut -f4- > Reformat/body3
paste Reformat/body1 Reformat/body2 Reformat/body3 > Reformat/body_final
cat Reformat/header Reformat/body_final > Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.vcf

#remove MT, W, Z, Unplaced
module purge
module load HTSlib/1.9-intel-2018b
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

vcftools --vcf Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.vcf --not-chr Chr_Z --not-chr Chr_W --not-chr Chr_MT --not-chr Chr_Unplaced --remove-filtered-all --recode --recode-INFO-all --stdout > Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.vcf
grep -v "#" Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.vcf | wc -l


cp Reformat/${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.vcf  .

#Remove related ind.
module purge
module load BCFtools/1.9-intel-2018b

bcftools view -s ^SPI002 -o ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.vcf -Ov ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.vcf
bcftools +fill-tags ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.vcf -o ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.update.vcf -Ov
bcftools view -i 'INFO/AC>0 && INFO/AC<34 ' -o ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.edit.vcf ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.update.vcf
grep -v "#" ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.edit.vcf | wc -l


mkdir SmartPCA

cd SmartPCA

cp ../${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.edit.vcf .

mv ${VCF_BASE}_MISS50_2all_maf5_ac36_reformat.Autosomes.NoRelate.edit.vcf SVs.Autosomes.NoRelate.vcf 

grep -v "#" SVs.Autosomes.NoRelate.vcf | wc -l


#GET FINAL SV INFO
module purge
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0
bcftools query -f '%CHROM\t%POS\n' SVs.Autosomes.NoRelate.vcf > SVs.Autosomes.NoRelate.vcf.chrpos
cp ../Manta_Smoove_Delly_Gridss.Autosomes_min2tools.vcf .
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_min2tools.vcf | cut -f1-2 > part1
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_min2tools.vcf | awk -F 'SVTYPE=' '{print $2}' | awk -F ';' '{print $1}' > part4
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_min2tools.vcf | awk -F 'END=' '{print $2}' | awk -F ';' '{print $1}' > part2 
grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_min2tools.vcf | awk -F 'SVLEN=' '{print $2}' | awk -F ';' '{print $1}' > part3 
paste part1 part2 part3 part4 > Variants.info
wc -l Variants.info

rm part*
grep -v "INV" Variants.info > Variants.noINV.info
wc -l Variants.noINV.info

grep "INV" Variants.info > Variants.INV.info
wc -l Variants.INV.info


grep -v "#" Manta_Smoove_Delly_Gridss.Autosomes_min2tools.vcf | grep "SVTYPE=INV" | while read line ;
do Chr=$(echo ${line} | cut -d " " -f1) ;
Pos=$(echo ${line} | cut -d " " -f2) ;
Length=$(echo ${line} | cut -d " " -f5 | awk '{print length}') ;
Length_edit=$(bc <<<"scale=1; ${Length} - 1") ;
End=$(bc <<<"scale=1; ${Pos} + ${Length_edit}") ;
echo -e "${Chr}\t${Pos}\t${End}\t${Length_edit}\tINV" >> INV.annot.info
done
wc -l INV.annot.info

cat INV.annot.info | sort | uniq > INV.annot.edit.info
wc -l INV.annot.edit.info


cat Variants.noINV.info INV.annot.info > Variants_all.info
wc -l Variants_all.info


cat SVs.Autosomes.NoRelate.vcf.chrpos | while read line ;
do Chr=$(echo $line | cut -d ' ' -f1) ;
Start=$(echo $line | cut -d ' ' -f2) ;
awk -F '\t' -v chr=${Chr} -v start=${Start} '{if ($1==chr && $2==start) print $1"\t"$2"\t"$3"\t"$4"\t"$5}' Variants_all.info >> SVs.Autosomes.NoRelate.vcf.EndLengthType.info
done

cut -f1,2 SVs.Autosomes.NoRelate.vcf.chrpos | sort > test1
cut -f1,2 SVs.Autosomes.NoRelate.vcf.EndLengthType.info | sort > test2
wc -l test1

wc -l test2


cat SVs.Autosomes.NoRelate.vcf.EndLengthType.info | sort -k1,1 -k2,2n > SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.info
awk '{if ($4 > 49 || $4 < -49) print $0}' SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.info > SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info

wc -l SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info


cat SVs.Autosomes.NoRelate.vcf | grep -v "#" | sort -k1,1 -k2,2n > body.sorted
cat SVs.Autosomes.NoRelate.vcf | grep "#" > header.sorted

cat SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info | while read line ;
do Chr=$(echo $line | cut -d ' ' -f1) ;
Start=$(echo $line | cut -d ' ' -f2) ;
awk -F '\t' -v chr=${Chr} -v start=${Start} '{if ($1==chr && $2==start) print $0}' body.sorted >> body.sorted.edit ;
done
cat header.sorted body.sorted.edit > SVs.Autosomes.NoRelate.sorted.filtered.vcf
wc -l body.sorted.edit 


rm header.sorted
rm body.sorted
rm body.sorted.edit

grep "INV" SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info | wc -l

grep "INS" SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info | wc -l

grep "DEL" SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info | wc -l

grep "DUP" SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info | wc -l


```

Then merge 

```bash
mkdir VG_Para

cd VG_Para

cp ../Paragraph/SmartPCA/SVs.Autosomes.NoRelate.sorted.filtered.vcf .
mv SVs.Autosomes.NoRelate.sorted.filtered.vcf Paragraph.SVs.Autosomes.NoRelate.sorted.filtered.vcf
cp ../Paragraph/SmartPCA/SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info .
mv SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info Paragraph.SVs.Autosomes.EndLengthType.info

cp ../VG/SmartPCA/SVs.Autosomes.NoRelate.sorted.filtered.vcf .
mv SVs.Autosomes.NoRelate.sorted.filtered.vcf VG.SVs.Autosomes.NoRelate.sorted.filtered.vcf
cp ../VG/SmartPCA/SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info .
mv SVs.Autosomes.NoRelate.vcf.EndLengthType.edit.sorted.filtered.info VG.SVs.Autosomes.EndLengthType.info

module purge
module load BCFtools/1.9-intel-2018b
bgzip VG.SVs.Autosomes.NoRelate.sorted.filtered.vcf
tabix VG.SVs.Autosomes.NoRelate.sorted.filtered.vcf.gz
bgzip Paragraph.SVs.Autosomes.NoRelate.sorted.filtered.vcf
tabix Paragraph.SVs.Autosomes.NoRelate.sorted.filtered.vcf.gz

zcat VG.SVs.Autosomes.NoRelate.sorted.filtered.vcf.gz | grep -v "#" | wc -l


zcat Paragraph.SVs.Autosomes.NoRelate.sorted.filtered.vcf.gz | grep -v "#" | wc -l

zcat Paragraph.SVs.Autosomes.NoRelate.sorted.filtered.vcf.gz | grep "#" > header

bcftools concat -a -D VG.SVs.Autosomes.NoRelate.sorted.filtered.vcf.gz Paragraph.SVs.Autosomes.NoRelate.sorted.filtered.vcf.gz -o Merged.SVs.Autosomes.NoRelate.Para_VG.vcf -Ov

#change header order
nano Merged.SVs.Autosomes.NoRelate.Para_VG.vcf #use header file

#total SVs
grep -v "#" Merged.SVs.Autosomes.NoRelate.Para_VG.vcf | wc -l 


#unique positions
grep -v "#" Merged.SVs.Autosomes.NoRelate.Para_VG.vcf | cut -f1,2 | sort | uniq | wc -l


#make overlap file and union vcf with VG GTs at overlap

zcat VG.SVs.Autosomes.NoRelate.sorted.filtered.vcf.gz | grep -v "#" > VG.body
zcat Paragraph.SVs.Autosomes.NoRelate.sorted.filtered.vcf.gz | grep -v "#" > Paragraph.body
cat Merged.SVs.Autosomes.NoRelate.Para_VG.vcf | grep -v "#" > Combined.body

grep -v "#" Merged.SVs.Autosomes.NoRelate.Para_VG.vcf | cut -f1,2 | sort | uniq | while read line ;
do Chr=$(echo $line | cut -d ' ' -f1) ;
Pos=$(echo $line | cut -d ' ' -f2) ;
ParValue=$(grep -w ${Chr} Combined.body | grep -w ${Pos} | grep "for_paragraph.edit.sorted.vcf" | cut -f2 ) ;
VGValue=$(grep -w ${Chr} Combined.body | grep -w ${Pos} | grep -v "for_paragraph.edit.sorted.vcf" | cut -f2 ) ;
if [[ ${ParValue} > 0 ]] && [[ ${VGValue} > 0 ]]
then
	echo -e "${Chr}\t${Pos}\t1\t1" >> Para_VG_overlap.txt
else
	if [[ ${VGValue} > 0 ]]
	then
		echo -e "${Chr}\t${Pos}\t1\t0" >> Para_VG_overlap.txt
	else
		echo -e "${Chr}\t${Pos}\t0\t1" >> Para_VG_overlap.txt
	fi
fi
awk -F '\t' -v chr=${Chr} -v start=${Pos} '{if ($1==chr && $2==start) print $0}' VG.body >> Combined.edit.body ;
awk -F '\t' -v chr=${Chr} -v start=${Pos} '{if ($1==chr && $2==start) print $0}' VG.SVs.Autosomes.EndLengthType.info >> Combined.SVs.Autosomes.EndLengthType.info ;
done

cat Combined.edit.body | cut -f1,2 > Used.positions
grep -v -f Used.positions Paragraph.body >> Combined.edit.body
grep -v -f Used.positions Paragraph.SVs.Autosomes.EndLengthType.info >> Combined.SVs.Autosomes.EndLengthType.info;

#sort those
grep "#" Merged.SVs.Autosomes.NoRelate.Para_VG.vcf | cat - Combined.edit.body > Merged.SVs.Autosomes.NoRelate.Para_VG.edit.vcf
bcftools sort -o Merged.SVs.Autosomes.NoRelate.Para_VG.edit.sorted.vcf -Ov Merged.SVs.Autosomes.NoRelate.Para_VG.edit.vcf

sort -k1,1 -k2,2n Combined.SVs.Autosomes.EndLengthType.info > Combined.SVs.Autosomes.EndLengthType.sorted.info
sort -k1,1 -k2,2n Para_VG_overlap.txt > Para_VG_overlap.sorted.txt

wc -l Para_VG_overlap.sorted.txt
wc -l Combined.SVs.Autosomes.EndLengthType.sorted.info
grep -v "#" Merged.SVs.Autosomes.NoRelate.Para_VG.edit.sorted.vcf | wc -l

cut -f5 Combined.SVs.Autosomes.EndLengthType.sorted.info | paste Para_VG_overlap.sorted.txt - > Para_VG_overlap.sorted.SVinfo.txt

for i in INV INS DUP DEL ;
do echo $i
grep -w $i Para_VG_overlap.sorted.SVinfo.txt > Para_VG_overlap.sorted.${i}.txt ;
done

module purge
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

#convert pruned and sorted vcf for smartPCA and make updated map file
#Get chromosome map for PLINK
bcftools view -H Merged.SVs.Autosomes.NoRelate.Para_VG.edit.sorted.vcf | cut -f 1 | uniq | awk '{print $0"\t"$0}' > SVs.Autosomes.NoRelate.vcf.chrom-map.txt
#Convert to Plink
vcftools --vcf Merged.SVs.Autosomes.NoRelate.Para_VG.edit.sorted.vcf --plink --chrom-map SVs.Autosomes.NoRelate.vcf.chrom-map.txt --out SVs.Autosomes.NoRelate.vcf

#Convert GT calls to 0,1,2
module purge
module load PLINK/1.9b_6.13-x86_64
plink -file SVs.Autosomes.NoRelate.vcf -aec -out SVs.Autosomes.NoRelate.vcf.edit -recode 12

# edit map file to only have chromosome numbers and to have a valid SNP identifier
cat SVs.Autosomes.NoRelate.vcf.edit.map | sed 's/Chr_//g' > SVs.Autosomes.NoRelate.vcf.edit2.map
awk '{print $1"\t"$1":"$4"\t"$3"\t"$4}' SVs.Autosomes.NoRelate.vcf.edit2.map > SVs.Autosomes.NoRelate.vcf.edit3.map

# update population information for each Individ. and save as the .pedind file
cat SVs.Autosomes.NoRelate.vcf.edit.ped | cut -d ' ' -f1-6 > tmp
cat SVs.Autosomes.NoRelate.vcf.edit.ped | cut -c1-3 | paste tmp - > SVs.Autosomes.NoRelate.vcf.edit.pedind
rm -rf tmp

# SmartPCA on LOCAL

conda activate eigensoft

smartpca -p PuffinSV_Autosomes_PCA_withoutlier.par > PuffinSV_Autosomes_PCALog_withOutlier.out

conda deactivate

paste SVs.Autosomes.NoRelate.vcf.edit3.map Combined.SVs.Autosomes.EndLengthType.sorted.info > ManhattanData.txt


# Fst calculation

module purge
module load BCFtools/1.9-intel-2018b
module load VCFtools/0.1.16-intel-2018b-Perl-5.28.0

# generate all the sample names
bcftools query -l Merged.SVs.Autosomes.NoRelate.Para_VG.edit.sorted.vcf > samples
# get the samples per population

grep "ROS" samples > rost
grep "SPI" samples > spitsbergen

#GLOBAL FST

vcftools --vcf Merged.SVs.Autosomes.NoRelate.Para_VG.edit.sorted.vcf \
--weir-fst-pop rost \
--weir-fst-pop spitsbergen \
--out ./ros_spi_SVs



```